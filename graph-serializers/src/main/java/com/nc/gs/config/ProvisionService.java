package com.nc.gs.config;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.TreeMap;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;

import com.nc.gs.log.Log;
import com.nc.gs.serializers.SingletonSerializer;
import com.nc.gs.util.Bits;
import com.nc.gs.util.Pair;
import com.nc.gs.util.Utils;

public class ProvisionService implements AutoCloseable {

	public static final class Builder {

		static void checkState() {
			synchronized (ProvisionService.class) {
				if (INSTANCE != null) {
					throw new IllegalStateException("Provision Service Already Constructed!!!");
				}
			}
		}

		boolean configFrozen;

		boolean failOnCNFE;

		int maxMem = 16 * 1024 * 1024;

		boolean onlyAutoMap;

		boolean skipResources;

		Builder() {
			checkState();
		}

		public ProvisionService bootstrap() {
			synchronized (ProvisionService.class) {
				checkState();

				ProvisionService service = new ProvisionService(maxMem, onlyAutoMap, configFrozen, skipResources, failOnCNFE);

				service.installMappings();

				INSTANCE = service;

				return service;
			}
		}

		public Builder skipResourceScan() {
			checkState();
			skipResources = true;
			return this;
		}

		public Builder useOnlyAutoMap() {
			checkState();
			onlyAutoMap = true;

			return this;
		}

		public Builder withMaxTableMemory(int mem) {
			checkState();
			int m = Utils.nextPowerOfTwo(mem);

			m = m < 0 ? 1 << 30 : m;
			maxMem = m;

			return this;
		}
	}

	public static Builder builder() {
		return new Builder();
	}

	public static synchronized ProvisionService getInstance() {
		ProvisionService ps = INSTANCE;
		if (ps == null) {
			ps = new ProvisionService(16 * 1024 * 1024, false, false, false, false);
			ps.installMappings();
			INSTANCE = ps;
		}
		return ps;
	}

	static List<URL> locateClasspathResources(ClassLoader cl, Set<String> nss) {
		if (nss == null || nss.isEmpty()) {
			return Collections.emptyList();
		}

		List<URL> rv = new ArrayList<>(nss.size());

		for (String ns : nss) {
			URL url = cl.getResource(String.format("META-INF/mappings/%s.xml", ns));

			if (url != null) {
				rv.add(url);
			}
		}

		return rv;
	}

	static Class<?>[] reserved() {
		return new Class<?>[]{ null, boolean.class, char.class, byte.class, short.class, int.class, float.class, long.class, double.class };
	}

	static volatile ProvisionService INSTANCE;

	Pair<int[], Pair<int[], Class<?>[]>> cd;

	final boolean configFrozen;

	final boolean failOnCNFE;

	final int maxMem;

	final boolean onlyAutoMap;

	Map<String, String> repMap;

	final boolean skipResources;

	TreeMap<Integer, ValidMapping> td;

	public ProvisionService(int maxMem, boolean onlyAutoMap, boolean configFrozen, boolean skipResources, boolean failOnCNFE) {
		super();
		this.maxMem = maxMem;
		this.onlyAutoMap = onlyAutoMap;
		this.configFrozen = configFrozen;
		this.skipResources = skipResources;
		this.failOnCNFE = failOnCNFE;
	}

	@Override
	public synchronized void close() {
		Pair<int[], Pair<int[], Class<?>[]>> p = cd;
		if (p != null) {
			Pair<int[], Class<?>[]> v = p.v;
			if (v != null) {
				v.k = null;
				v.v = null;
				p.v = null;
			}
		}
		cd = null;

		TreeMap<Integer, ValidMapping> m = td;

		if (m != null) {
			// Force Unlinking to help gc
			Iterator<Entry<Integer, ValidMapping>> itr = m.entrySet().iterator();
			while (itr.hasNext()) {
				itr.next();
				itr.remove();
			}
			m.clear();
		}

		td = null;

		INSTANCE = null;
	}

	/**
	 * <p>
	 * Attempts to evaluate the smallest required prime number required to ensure a 'perfect
	 * hashing' scheme. By 'perfect' we mean we can find a prime number P, such that
	 * {@link Class#hashCode()} % P evaluates maps to a unique number for every {@link ValidMapping}
	 * 's type, that is, we can normalize the hashes to a small sub-set of numbers.
	 * </p>
	 * <p>
	 * This method assumes that all hashCodes generated by {@link System#identityHashCode(Object)}
	 * are positive numbers, which, at least for <a href=
	 * "http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp"
	 * >hotspot</a> VM, which stores the identity hash either as a 25bit number (32bit VM) or as a
	 * 31bit number (64bit VM), is true.
	 * </p>
	 * <p>
	 * Bellow, an excerpt of markOop.hpp. If by any chance the VM changes the hashing scheme, we'd
	 * have to mask the hash with 0x7fffffff in order to obtain a positive number.
	 * </p>
	 *
	 * <pre>
	 * 32 bits: -------- hash:25 ------------>| age:4 biased_lock:1 lock:2
	 *
	 * 64 bits: -------- unused:25 hash:31 -->| unused:1 age:4 biased_lock:1
	 * lock:2
	 * </pre>
	 * <p>
	 * If we succeed to find a perfect hash, we can be sure that we can create the mapping
	 * {@link Class}<=>int in a way that lookups can be made loop/recursion-free. If the required
	 * number for the perfect hash is too big, it might be faster to fall back to loop based lookups
	 * due to cache line effects.
	 * </p>
	 * <p>
	 * The association of a type with an index could also have been done with a power of two
	 * approach, which would use a lesser expensive operation (hash & (P-1)), where P is a power of
	 * two. This however, tends to require a much larger P than with prime approach. For 230
	 * mappings, the power of two normalization requires about 64K slots, whilst the prime
	 * </p>
	 *
	 * @param fullMap
	 *            all known types
	 */
	private void evaluateTypes(TreeMap<Integer, ValidMapping> fullMap) {

		validateReservedMappings(fullMap);

		// TIntHashMap still crashing VM!!!
		HashMap<Integer, Class<?>> hashes = new HashMap<Integer, Class<?>>();

		Collection<ValidMapping> values = fullMap.values();

		int p = Bits.nextPrime(values.size() << 1);
		int sz = p << 2;

		Integer success = null;
		int largest = -1;

		l: while (sz > 0 && sz <= maxMem && p > 0) {

			for (ValidMapping vm : values) {
				// Identity Hash Codes are always positive!
				int ix = vm.type.hashCode() % p;

				if (ix > largest) {
					largest = ix;
				}

				Class<?> old;

				if ((old = hashes.put(ix, vm.type)) != null) {
					p = Bits.nextPrime(p + 1);
					sz = p << 2;
					hashes.clear();
					largest = -1;

					Log.debug("Detected Hash collision: [%s,%d]<=>[%s,%d], expanding to %d", vm.type.getName(), ix, old.getName(), ix, p);

					continue l;
				}
			}

			success = p;
			break;
		}

		hashes.clear();

		int[] cids = new int[fullMap.lastKey() + 1];
		Class<?>[] types = new Class<?>[fullMap.lastKey() + 1];
		Set<Entry<Integer, ValidMapping>> es = fullMap.entrySet();

		for (Entry<Integer, ValidMapping> e : es) {
			int ix = e.getKey();
			cids[ix] = ix;
			types[ix] = e.getValue().type;
		}

		cd = Pair.of(success == null ? null : new int[]{ success, largest + 1 }, Pair.of(cids, types));
	}

	public Pair<int[], Pair<int[], Class<?>[]>> getClassData() {
		return cd == null ? Pair.<int[], Pair<int[], Class<?>[]>> of(null, reservedOnly()) : cd;
	}

	public Map<String, String> getReplacements() {
		return repMap;
	}

	public TreeMap<Integer, ValidMapping> getTypeData() {
		return td;
	}

	void installMappings() {
		if (skipResources) {
			return;
		}

		ServiceLoader<NamespaceLocationService> lookups = ServiceLoader.load(NamespaceLocationService.class);

		Set<String> nss = new HashSet<>();

		Set<URL> urls = new HashSet<>();

		for (NamespaceLocationService service : lookups) {

			List<String> locs = service.enumerateNamespaces();

			if (locs != null) {
				nss.addAll(locs);
			}

			List<URL> res = service.enumerateResources();

			if (res != null) {
				urls.addAll(res);
			}
		}

		urls.addAll(locateClasspathResources(getClass().getClassLoader(), nss));

		TreeMap<Integer, ValidMapping> fullMap = new TreeMap<>();
		// Unmarshaller u = newUnmarshaller();

		XMLInputFactory factory = XMLInputFactory.newFactory();

		for (URL url : urls) {
			try {
				// TypeMappings tm = (TypeMappings) u.unmarshal(url);
				List<TypeMappings> tms = TypeMappings.parse(factory, url);
				installMappings(tms, fullMap);
			} catch (XMLStreamException | IOException e) {
				throw new RuntimeException(e);
			}
		}

		evaluateTypes(fullMap);

		td = fullMap;
	}

	private void installMappings(List<TypeMappings> tms, TreeMap<Integer, ValidMapping> fullMap) {
		for (TypeMappings tm : tms) {
			installMappings(tm, fullMap);
		}
	}

	private void installMappings(TypeMappings tm, TreeMap<Integer, ValidMapping> fullMap) {

		Map<String, String> map = tm.getReplacements();

		if (map != null) {
			if (repMap == null) {
				repMap = new HashMap<String, String>();
			}
			repMap.putAll(map);
		}

		Set<Mapping> mappings = tm.getMappings(failOnCNFE);

		for (Mapping m : mappings) {
			try {
				Object rt = m.resolveTypeOrSingleton();
				Object gs;
				int id = m.getTypeId();

				if (id == 0) {
					throw new IllegalMappingException(m.toString());
				}

				Class<?> resolvedType;
				Object resolvedObject;

				if (rt instanceof Class<?>) {
					resolvedType = (Class<?>) rt;
					String ser = m.getSerializer();

					if (ser != null && m.getSerializerLookup() != null) {
						gs = Class.forName(ser).getDeclaredMethod(m.getSerializerLookup()).invoke(null);
					} else {
						gs = ser;
					}

					resolvedObject = null;
				} else {
					resolvedObject = rt;
					resolvedType = rt.getClass();
					gs = new SingletonSerializer(rt);
				}

				ValidMapping pair = new ValidMapping(resolvedType, resolvedObject, gs, m.getIncludes(), m.isOpaque(), m.isSkipReify());

				ValidMapping old = fullMap.put(id, pair);

				if (old != null) {
					throw new IllegalMappingException(String.format("Type id %d is being shared by types: %s and %s. Mappings must be unique.", id, old.type.getName(), resolvedType.getName()));
				}
			} catch (ReflectiveOperationException e) {
				e.printStackTrace();
			}
		}
	}

	// @SuppressWarnings("restriction")
	// Unmarshaller newUnmarshaller() {
	// try {
	// return JAXBContext.newInstance(TypeMappings.class)
	// .createUnmarshaller();
	// } catch (JAXBException e) {
	// Utils.U.throwException(e);
	// return null;
	// }
	// }

	public boolean isConfigFrozen() {
		return configFrozen;
	}

	public boolean isOnlyAutoMap() {
		return onlyAutoMap;
	}

	private Pair<int[], Class<?>[]> reservedOnly() {
		Class<?>[] types = reserved();

		int[] tIds = new int[types.length];

		for (int i = 0; i < tIds.length; i++) {
			tIds[i] = i;
		}

		return Pair.of(tIds, types);
	}

	private void validateReservedMappings(TreeMap<Integer, ValidMapping> fullMap) {

		Class<?>[] types = reserved();

		for (int i = 1; i < types.length; i++) {
			ValidMapping mapping = fullMap.get(i);

			Class<?> type = mapping == null ? null : mapping.type;

			if (type != types[i]) {
				throw new IllegalMappingException(String.format("Reserved types MUST be mapped in the range [1,%d]. Offending mapping: %s, id=%d", types.length - 1, type, i));
			}
		}
	}

}