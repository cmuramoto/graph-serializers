graph-serializers
=================

#### Goals

This project aims to provide high performance java serialization by performing class analysis and creating the corresponding efficient serializers on the fly, aiming for zero-reflection whenever possible.

This framework is a non-invasive, inheritance-based serialization solution, that tries its hardest to be as efficient as frameworks that rely on static schemas such as protocol buffers and thrift.

##### Features

This library is intended to be use as a serialization library for (possibly) cyclic domain models and can be optimized to work with flat models (no cyclic detection) with a field-level glanularity. For example, supose we have the following class:

```java
public class Node {
  
  Node left;
  
  Node right;
  
  String label;
}
```

Let's say left and right might be cyclic, however we know that the *label* will never be repeated when serializing a graph of nodes. In this case, we can just forfeit reference marking of the label field in order to reduce a bit the processing overhead and as well as save a few bytes on the final binary payload of the object graph. To let go reference marking of the *label* field we just have to decorate it with some metadata.

```java
public class Node {
  
  Node left;
  
  Node right;
  
  @OnlyPayload
  String label;
}
```

#### Simple Usage



#### Benchmarks



##### The Numbers

The numbers in the charts bellow correspond to a slightly modified version of the old [thrift x protobuff](http://thrift-protobuf-compare.googlecode.com/svn/trunk/) benchmark code. In practice, this benchmark is almost all about String serialization performance.

It should be noted that protobuff uses a nice internal representation for a String called ByteString, which is ultra-fast to be (de-)serialized however in practice one should take into account the *pre-processing* time required by the framework to perform the conversion *String->ByteString* during the construction of an Object (Message)  and the *post-processing* in order for one to get a java.lang.String out of a com.google.protobuf.ByteString after deserialization.

The following chart displays the overall serialization cost (Time to instantiate+Serialize)

![][ser]


Next the deserialization time with and without round-trip validation. 

![][des]
![][desall]

In the first case, protobuf has a HUGE advantage because it is only deserializing it's ByteStrings, which comes down to just copying bytes from a stream without any processing involved. However, during round-trip validation, every field has to pass a simple assertion test, which implies that some conversions *ByteString->String* end up taking a considerable amount of time.

If we give up String compression during (de-)serialization, by writing the contents of a String as a 'raw' char[], we end up with the following numbers:

![][des-stringopt]

![][desall-stringopt]

So, as we can see this benchmark is more about String serialization performance than anything, however we are able to match the messages generated by *protoc* and even surpass it, considerably, if we let go String compression.

##### The model

For the benchmarks we have used the following structure protocol buffer messages: 

```c
package domain.protobuf;

option java_package = "domain.protobuf";
option java_outer_classname = "MediaContentHolder";
option optimize_for = SPEED;

message Image {
  required string uri = 1;      //url to the thumbnail
  optional string title = 2;    //used in the html ALT
  optional int32 width = 3;     // of the image
  optional int32 height = 4;    // of the image
  enum Size {
    SMALL = 0;
    LARGE = 1;
  }
  optional Size size = 5;       // of the image (in relative terms, provided by cnbc for example)
}

message Person {
  required string name = 1;      //url to the thumbnail
}  
  

message Media {
  required string uri = 1;      //uri to the video, may not be an actual URL
  optional string title = 2;    //used in the html ALT
  optional int32 width = 3;     // of the video
  optional int32 height = 4;    // of the video
  optional string format = 5;   //avi, jpg, youtube, cnbc, audio/mpeg formats ...
  optional int64 duration = 6;  //time in miliseconds
  optional int64 size = 7;      //file size
  optional int32 bitrate = 8;   //video 
  repeated Person person = 9;   //name of a person featured in the video
  enum Player {
    JAVA = 0;
    FLASH = 1;
  }
  optional Player player = 10;   //in case of a player specific media
  optional string copyright = 11;//media copyright
}

message MediaContent {
  repeated Image image = 1;
  optional Media media = 2;
}
```

Likewise, for the Thrift code we have used the following media.thrift file:

```c
namespace java domain.thrift

typedef i32 int
typedef i64 long

enum Size {
  SMALL = 1,
  LARGE = 2,
}

enum Player {
  JAVA = 0,
  FLASH = 1,
}

/**
 * Some comment...
 */
struct Person {
  1: string name,              //name 
} 
 
struct Image {
  1: string uri,              //url to the images
  2: optional string title,  
  3: optional int width,
  4: optional int height,
  5: optional Size size,
}

struct Media {
  1: string uri,             //url to the thumbnail
  2: optional string title,
  3: optional int width,
  4: optional int height,
  5: optional string format,
  6: optional long duration,
  7: optional long size,
  8: optional int bitrate,
  9: optional list<Person> person,
  10: optional Player player,
  11: optional string copyright,
}

struct MediaContent {
  1: optional list<Image> image,
  2: optional Media media,
}

```

On the other hand, the java classes used by the framework were simple POJOs, without (almost) any metadatada in order to turn them into optimized data structures. For the **MediaContent** class the java code reads:

```java
@Fields(compressByDefault = true)
public class MediaContent implements Serializable {
	private static final long serialVersionUID = 1L;

	@NotNull
	@OnlyPayload
	@Collection(concreteImpl = ArrayList.class, optimize = true, shape = @Shape(hierarchy = @Hierarchy(types = { Image.class }, complete = true), nullable = false, onlyPayload = true))
	public List<Image> images;

	@LeafNode
	@NotNull
	@OnlyPayload
	public Media media;

	//gets, sets, etc...
}


```

The annotations aren't realy necessary, however to make the benchmark more apples-to-apples we used some annotations to inform the graph-serializers framework to make certain optimizations.

##### Methodology

//TODO

#### Optimizations

##### @LeafNode

##### @Hierarchy - Making inline caches

[ser]: https://cloud.githubusercontent.com/assets/7014591/5587308/06088ee6-90ce-11e4-9a3d-9c446fb0933e.png
[des]: https://cloud.githubusercontent.com/assets/7014591/5587302/05e9a9d6-90ce-11e4-8dce-69bbd5d171a6.png
[desall]: https://cloud.githubusercontent.com/assets/7014591/5587303/05eb2d6a-90ce-11e4-842f-d185b27dc0bf.png
[desall-stringopt]: https://cloud.githubusercontent.com/assets/7014591/5587301/05e8d5f6-90ce-11e4-8642-16ffec736894.png
[des-stringopt]: https://cloud.githubusercontent.com/assets/7014591/5587304/05ecb8ba-90ce-11e4-9cc0-7e74cb5aa9af.png
